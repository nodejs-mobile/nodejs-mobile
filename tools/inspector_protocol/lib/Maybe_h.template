// This file is generated by Maybe_h.template.

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef {{"_".join(config.protocol.namespace)}}_Maybe_h
#define {{"_".join(config.protocol.namespace)}}_Maybe_h

//#include "Forward.h"

{% for namespace in config.protocol.namespace %}
namespace {{namespace}} {
{% endfor %}

namespace detail {
template<typename T>
class PtrMaybe {
public:
    PtrMaybe() = default;
    PtrMaybe(std::unique_ptr<T> value) : m_value(std::move(value)) { }
    PtrMaybe(PtrMaybe&& other) noexcept : m_value(std::move(other.m_value)) {}
    void operator=(std::unique_ptr<T> value) { m_value = std::move(value); }
    T* fromJust() const { DCHECK(m_value); return m_value.get(); }
    T* fromMaybe(T* defaultValue) const { return m_value ? m_value.get() : defaultValue; }
    bool isJust() const { return !!m_value; }
    std::unique_ptr<T> takeJust() { DCHECK(m_value); return std::move(m_value); }
private:
    std::unique_ptr<T> m_value;
};

template<typename T>
class ValueMaybe {
public:
    ValueMaybe() : m_isJust(false), m_value() { }
    ValueMaybe(T value) : m_isJust(true), m_value(std::move(value)) { }
    ValueMaybe(ValueMaybe&& other) noexcept
        : m_isJust(other.m_isJust),
          m_value(std::move(other.m_value)) {}
    void operator=(T value) { m_value = value; m_isJust = true; }
    const T& fromJust() const { DCHECK(m_isJust); return m_value; }
    const T& fromMaybe(const T& defaultValue) const { return m_isJust ? m_value : defaultValue; }
    bool isJust() const { return m_isJust; }
    T takeJust() { DCHECK(m_isJust); return std::move(m_value); }
private:
    bool m_isJust;
    T m_value;
};

template <typename T>
struct MaybeTypedef { typedef PtrMaybe<T> type; };

template <>
struct MaybeTypedef<bool> { typedef ValueMaybe<bool> type; };

template <>
struct MaybeTypedef<int> { typedef ValueMaybe<int> type; };

template <>
struct MaybeTypedef<double> { typedef ValueMaybe<double> type; };

template <>
struct MaybeTypedef<String> { typedef ValueMaybe<String> type; };

template <>
struct MaybeTypedef<Binary> { typedef ValueMaybe<Binary> type; };

}  // namespace detail

template <typename T>
using Maybe = typename detail::MaybeTypedef<T>::type;

{% for namespace in config.protocol.namespace %}
} // namespace {{namespace}}
{% endfor %}

#endif // !defined({{"_".join(config.protocol.namespace)}}_Maybe_h)
